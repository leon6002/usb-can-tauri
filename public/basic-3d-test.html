<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>基础3D测试</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>基础3D按钮测试</h3>
        <p>应该看到两个蓝色圆形按钮</p>
        <p>点击按钮测试交互</p>
    </div>

    <!-- Three.js 库 -->
    <script src="car-assets/js/three.min.js"></script>
    <script src="car-assets/js/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let buttons = [];
        let raycaster, mouse;

        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);

            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 创建控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 创建光源
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // 创建地面
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // 创建测试按钮
            createTestButtons();

            // 设置射线检测
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // 添加事件监听器
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);

            // 开始渲染循环
            animate();

            console.log('基础3D场景初始化完成');
        }

        function createTestButtons() {
            // 左按钮
            const leftButton = createButton(-2, 1, 0, 'left');
            buttons.push(leftButton);

            // 右按钮
            const rightButton = createButton(2, 1, 0, 'right');
            buttons.push(rightButton);

            console.log('创建了', buttons.length, '个测试按钮');
        }

        function createButton(x, y, z, side) {
            const geometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
            const material = new THREE.MeshPhongMaterial({
                color: 0x00BFFF,
                emissive: 0x004080,
                shininess: 100
            });

            const button = new THREE.Mesh(geometry, material);
            button.position.set(x, y, z);
            button.castShadow = true;

            button.userData = {
                isButton: true,
                side: side,
                originalColor: 0x00BFFF,
                hoverColor: 0x40CFFF,
                clickColor: 0x0080FF
            };

            scene.add(button);
            console.log(`创建${side}按钮，位置: (${x}, ${y}, ${z})`);
            return button;
        }

        function onMouseClick(event) {
            // 计算鼠标位置
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // 射线检测
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(buttons);

            if (intersects.length > 0) {
                const clickedButton = intersects[0].object;
                handleButtonClick(clickedButton);
            }
        }

        function onMouseMove(event) {
            // 计算鼠标位置
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // 射线检测
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(buttons);

            // 重置所有按钮颜色
            buttons.forEach(button => {
                button.material.color.setHex(button.userData.originalColor);
                button.material.emissive.setHex(0x004080);
            });

            // 设置悬停按钮颜色
            if (intersects.length > 0) {
                const hoveredButton = intersects[0].object;
                hoveredButton.material.color.setHex(hoveredButton.userData.hoverColor);
                hoveredButton.material.emissive.setHex(0x0060A0);
                renderer.domElement.style.cursor = 'pointer';
            } else {
                renderer.domElement.style.cursor = 'default';
            }
        }

        function handleButtonClick(button) {
            const side = button.userData.side;
            
            // 按钮点击效果
            button.material.color.setHex(button.userData.clickColor);
            setTimeout(() => {
                button.material.color.setHex(button.userData.originalColor);
            }, 150);

            console.log(`点击了${side}按钮！`);
            alert(`点击了${side}按钮！`);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 事件监听器
        window.addEventListener('load', init);
        window.addEventListener('resize', onWindowResize);
    </script>
</body>
</html>
